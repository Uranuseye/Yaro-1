"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function getQualifiedName(node) {
  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
}

function removeTypeDuplicates(nodes) {
<<<<<<< HEAD
  const generics = new Map();
  const bases = new Map();
=======
  const generics = {};
  const bases = {};
>>>>>>> f8201306ba786516c9825d88012c1e0b5966996d
  const typeGroups = new Set();
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
<<<<<<< HEAD
      bases.set(node.type, node);
=======
      bases[node.type] = node;
>>>>>>> f8201306ba786516c9825d88012c1e0b5966996d
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (!typeGroups.has(node.types)) {
        nodes = nodes.concat(node.types);
        typeGroups.add(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      const name = getQualifiedName(node.id);

<<<<<<< HEAD
      if (generics.has(name)) {
        let existing = generics.get(name);
=======
      if (generics[name]) {
        let existing = generics[name];
>>>>>>> f8201306ba786516c9825d88012c1e0b5966996d

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
<<<<<<< HEAD
        generics.set(name, node);
=======
        generics[name] = node;
>>>>>>> f8201306ba786516c9825d88012c1e0b5966996d
      }

      continue;
    }

    types.push(node);
  }

<<<<<<< HEAD
  for (const [, baseType] of bases) {
    types.push(baseType);
  }

  for (const [, genericName] of generics) {
    types.push(genericName);
  }

  return types;
}

//# sourceMappingURL=removeTypeDuplicates.js.map
=======
  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}
>>>>>>> f8201306ba786516c9825d88012c1e0b5966996d
